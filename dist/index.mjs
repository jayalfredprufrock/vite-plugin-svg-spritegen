import path from "node:path";
import { hash } from "node:crypto";
import { watch } from "chokidar";
import { normalizePath, createFilter } from "vite";
import { promises, readFileSync, writeFileSync } from "node:fs";
import fastGlob from "fast-glob";
import { parse } from "node-html-parser";
import { optimize } from "svgo";
const buildSvgMap = async (inputConfigs) => {
  const svgMap = /* @__PURE__ */ new Map();
  await Promise.all(
    inputConfigs.map(async (inputConfig) => {
      const { pattern, baseDir, getSymbolId } = inputConfig;
      const matchedPaths = await fastGlob(pattern, { cwd: baseDir });
      await Promise.all(
        matchedPaths.map(async (matchPath) => {
          const filePath = path.join(baseDir, matchPath);
          const content = await promises.readFile(filePath, "utf8");
          const resolvedInputConfig = {
            ...inputConfig,
            content,
            matchPath,
            filePath
          };
          const symbolId = getSymbolId(resolvedInputConfig);
          if (svgMap.has(symbolId)) {
            console.log(
              `Duplicate SVG symbol id "${symbolId}. Symbol ids should be unique across all inputs."`
            );
            return;
          }
          svgMap.set(symbolId, { ...resolvedInputConfig, symbolId });
        })
      );
    })
  );
  return svgMap;
};
const writeIfChanged = (filePath, content) => {
  try {
    const currentContent = readFileSync(filePath, "utf8");
    if (content && currentContent !== content) {
      writeFileSync(filePath, content, "utf8");
      return true;
    }
    return false;
  } catch (e) {
    writeFileSync(filePath, content ?? "", "utf8");
    return true;
  }
};
const writeTypes = async (filePath, svgMap) => {
  const iconNames = [...svgMap.keys()];
  const content = [
    "/* eslint-disable */",
    "",
    "// This file is autogenerated. Do not commit to source control.",
    "",
    "export type IconName = (typeof iconNames)[number];",
    "",
    "export const iconNames = [",
    ...iconNames.map((name) => `  '${name}',`),
    "] as const;",
    ""
  ].join("\n");
  await writeIfChanged(filePath, content);
};
const writeGitignore = async (filePath, spriteName, typesName) => {
  const content = ["# svg spritegen", spriteName, typesName].join("\n");
  try {
    const currentContent = await promises.readFile(filePath, "utf8");
    if (currentContent.includes(content)) {
      return;
    } else {
      await promises.writeFile(filePath, currentContent + "\n" + content, "utf8");
    }
  } catch (e) {
    await promises.writeFile(filePath, content, "utf8");
  }
};
const writeSprite = (spritePath, svgMap) => {
  const symbols = [];
  const definitions = [];
  const svgSorted = [...svgMap].sort((a, b) => String(a[0]).localeCompare(b[0])).map(([_, svg]) => svg);
  for (const svg of svgSorted) {
    if (spritePath === svg.filePath) continue;
    let content2 = svg.content;
    if (svg.svgo !== false) {
      content2 = optimize(content2, {
        ...svg.svgo,
        plugins: [
          ...svg.svgo.plugins ?? [],
          ...svg.removeAttrs.length ? [
            {
              name: "removeAttrs",
              params: {
                attrs: `(${svg.removeAttrs.join("|")})`
              }
            }
          ] : [],
          ...svg.svgoPlugins
        ]
      }).data;
    }
    const svgEl = parse(content2).querySelector("svg");
    if (!svgEl) {
      throw new Error(`SVG file at path "${svg.filePath}" does not contain an svg tag.`);
    }
    svgEl.tagName = "symbol";
    svgEl.setAttribute("id", svg.symbolId);
    svgEl.removeAttribute("xmlns");
    svgEl.removeAttribute("xmlns:xlink");
    svgEl.removeAttribute("version");
    const defs = svgEl.querySelector("defs");
    if (defs) {
      defs.childNodes.forEach((def) => definitions.push(def.toString()));
      svgEl.removeChild(defs);
    }
    symbols.push(svgEl.toString());
  }
  const lines = [
    '<?xml version="1.0" encoding="UTF-8"?>',
    '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="0" height="0">'
  ];
  if (definitions.length) {
    lines.push("  <defs>", ...definitions.map((d) => `    ${d}`), "  </defs>");
  }
  lines.push(...symbols.map((s) => `  ${s}`), "</svg>");
  const content = lines.join("\n");
  writeIfChanged(spritePath, content);
  return content;
};
const svgoDefault = {
  plugins: [
    {
      name: "preset-default",
      params: {
        overrides: {
          removeViewBox: false,
          convertColors: { currentColor: true }
        }
      }
    },
    "removeDimensions",
    {
      name: "removeAttrs",
      params: { attrs: "(stroke-width|stroke-linecap|stroke-linejoin|class)" }
    }
  ]
};
const defaultMatchPattern = /(?:(?:name)|(?:iconName)|(?:icon)): "(?<icon>.+?)"/g;
const inputConfigDefaults = {
  pattern: "**/*.svg",
  baseDir: "./",
  prefix: "",
  removeAttrs: [],
  svgo: svgoDefault,
  svgoPlugins: [],
  getSymbolId: (config) => config.prefix + config.matchPath.replace(/\.[^/.]+$/, "").replaceAll("/", "-").toLowerCase()
};
const stripUnusedDefaults = {
  enabled: true,
  srcInclude: "**/*.[jt]sx",
  srcExclude: [],
  whitelist: []
};
function svgSpritegen(config) {
  const inputConfigs = Array.isArray(config.input) ? config.input : [config.input ?? inputConfigDefaults];
  const inputConfigsResolved = inputConfigs.map((inputConfig) => {
    const baseDir = path.resolve(process.cwd(), inputConfig.baseDir ?? inputConfigDefaults.baseDir);
    return {
      ...inputConfigDefaults,
      ...inputConfig,
      baseDir
    };
  });
  const stripUnusedResolved = { ...stripUnusedDefaults };
  if (typeof config.stripUnused === "object") {
    Object.assign(stripUnusedResolved, config.stripUnused);
  } else if (config.stripUnused === false) {
    stripUnusedResolved.enabled = false;
  }
  const outputPath = path.resolve(process.cwd(), config.outputDir);
  const spriteNameResolved = config.spriteFileName ?? "sprite.svg";
  const typesFilePath = normalizePath(path.join(outputPath, config.typesFileName ?? "types.ts"));
  const spriteFilePath = normalizePath(path.join(outputPath, spriteNameResolved));
  const gitignoreFilePath = normalizePath(path.join(outputPath, ".gitignore"));
  const { srcInclude, srcExclude } = stripUnusedResolved;
  const srcExcludeResolved = ["node_modules/**", srcExclude].flat().filter((e) => e !== null);
  const srcFilter = createFilter(srcInclude, srcExcludeResolved);
  let watcher;
  let allSvgs;
  const referencedSvgs = /* @__PURE__ */ new Map();
  let isBuild = false;
  let finalSpriteContent = "";
  return {
    name: "svg-spritegen",
    enforce: "post",
    configResolved(config2) {
      isBuild = config2.command === "build";
    },
    async buildStart() {
      allSvgs = await buildSvgMap(inputConfigsResolved);
      await writeTypes(typesFilePath, allSvgs);
      if (config.gitignore !== false) {
        await writeGitignore(gitignoreFilePath, "sprite.svg", "types.ts");
      }
      if (isBuild) {
        if (stripUnusedResolved.enabled) {
          writeIfChanged(spriteFilePath);
        } else {
          writeSprite(spriteFilePath, allSvgs);
        }
        return;
      }
      writeSprite(spriteFilePath, allSvgs);
      const onWatch = (path2) => {
        if (path2 === spriteFilePath) return;
        buildSvgMap(inputConfigsResolved).then((newAllSvgFiles) => {
          writeSprite(spriteFilePath, newAllSvgFiles);
        });
      };
      const inputPaths = inputConfigsResolved.map((config2) => config2.baseDir);
      watcher = watch(inputPaths, { ignoreInitial: true }).on("add", onWatch).on("change", onWatch).on("unlink", onWatch);
    },
    moduleParsed(info) {
      if (!isBuild || !stripUnusedResolved.enabled || !srcFilter(info.id) || !info.code) return;
      const matchPattern = config.matchPattern ? new RegExp(config.matchPattern, "g") : defaultMatchPattern;
      const matches = [...info.code.matchAll(matchPattern)].flatMap(
        ({ groups }) => (groups == null ? void 0 : groups.icon) ?? []
      );
      matches.push(...stripUnusedResolved.whitelist);
      for (const match of matches) {
        if (referencedSvgs.has(match)) continue;
        const svg = allSvgs.get(match);
        if (!svg) continue;
        referencedSvgs.set(match, svg);
      }
    },
    outputOptions(options) {
      if (!stripUnusedResolved.enabled) return null;
      finalSpriteContent = writeSprite(spriteFilePath, referencedSvgs);
      return {
        ...options,
        assetFileNames: (asset) => {
          var _a;
          const name = typeof options.assetFileNames === "string" ? options.assetFileNames : ((_a = options.assetFileNames) == null ? void 0 : _a.call(options, asset)) ?? "assets/[name]-[hash][extname]";
          if (asset.names.includes(spriteNameResolved)) {
            return name.replace(
              "[hash]",
              hash("sha256", finalSpriteContent, "hex").substring(0, 8)
            );
          } else {
            return name;
          }
        }
      };
    },
    async generateBundle(_options, bundle) {
      if (stripUnusedResolved.enabled) {
        Object.values(bundle).forEach((file) => {
          if (file.type === "asset" && file.names.includes(spriteNameResolved)) {
            file.source = finalSpriteContent;
          }
        });
      }
    },
    async closeBundle() {
      await (watcher == null ? void 0 : watcher.close());
    }
  };
}
export {
  svgSpritegen
};
